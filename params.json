{"name":"Neoasync","tagline":"NeoAsync is a growing toolset to manage asynchronous tasks when programming in Unity3D","body":"# NeoAsync: A class library for asynchronous tasks in `Unity3D`\r\n\r\nNeoAsync is a growing toolset to manage asynchronous tasks when programming in Unity3D\r\n\r\n## Installation\r\n\r\nIf you don't have access to [Microsoft VisualStudio](http://msdn.microsoft.com/de-de/vstudio) you can just use Unity3D and its compiler.\r\nOr use your VisualStudio installation in combination with [Visual Studio Tools for Unity](http://unityvs.com) to compile a DLL-file, which\r\ncan be included into your project.\r\n\r\n### Using Unity3D\r\n\r\n* Clone the repository\r\n* Copy the files from `Assets\\NeoAsync` into your project\r\n\r\n### Using VisualStudio\r\n\r\n* Clone the repository\r\n* Open the folder as a Unity3D project\r\n* Install the *free* [Unity Testing Tools](https://www.assetstore.unity3d.com/#/content/13802) from the AssetStore\r\n* Install the *free* [Visual Studio Tools for Unity](http://unityvs.com) and import its Unity-package\r\n* Open `UnityVS.NeoAsync.sln`\r\n* [Build a DLL-File](http://forum.unity3d.com/threads/video-tutorial-how-to-use-visual-studio-for-all-your-unity-development.120327)\r\n* Import the DLL and dependencies into your Unity3D project\r\n\r\n## Dependencies\r\n\r\n* [NeoCollections](https://github.com/jnbt/NeoCollections)\r\n\r\n## Usage\r\n\r\n### `CoroutineStarter`\r\n\r\nAllows starting a Unity-based coroutine from any instance.\r\n\r\n```csharp\r\nclass SomeClass {\r\n  public void Do(){\r\n    CoroutineStarter.Instance.Add(doLazy());\r\n  }\r\n  private IEnumerator doLazy(){\r\n    yield return UnityEngine.WaitForSeconds(5f);\r\n    UnityEngine.Debug.Log(\"This should be invoked as a coroutine\");\r\n  }\r\n}\r\n```\r\n\r\n### Cache\\<T\\>\r\n\r\nProvides a generic cache for any kind of objects which loading might need some time and can be referenced by a string key.\r\n\r\n```csharp\r\nclass SomeClass{\r\n  private readonly Cache<UnityEngine.GameObject> cache;\r\n  public SomeClass(){\r\n    cache = new Cache<UnityEngine.GameObject>(resolveGameObject);\r\n  }\r\n  public void Do(){\r\n    cache.Get(\"MyBigGameObject\", (go) => go.transform.position = UnityEngine.Vector3.zero);\r\n  }\r\n  private GameObject resolveGameObject(string key){\r\n    UnityEngine.Resources.Load<GameObject>(key);\r\n  }\r\n}\r\n```\r\n\r\n### Timing / ITiming\r\n\r\nAllows easy time-driven callbacks:\r\n\r\n* After(seconds, callback): Invokes a callback after the timeout in seconds.\r\n* Every(seconds, callback): Invokes a callback every x seconds. First time in x seconds.\r\n\r\n```csharp\r\n// In the best case inject a Timing instance\r\n[Inject]\r\npublic ITiming Timing { get; set; }\r\n\r\n// Than in your functions created a deferred call\r\nIDeferred after = Timing.After(5, () => UnityEngine.Debug.Log(\"This will be invoked in 5 seconds\"));\r\n\r\n// You can abort the call (if not already executed)\r\nafter.Abort();\r\n\r\n// Also a interval-based variant is available for convience\r\nTiming.Every(5, () => UnityEnging.Debug.Log(\"This will be invoked EVERY 5 seconds\"));\r\n\r\n```\r\n\r\nBy using an Dependency-Injection pattern / framework (e.g. [Strange](https://github.com/strangeioc/strangeioc)) unit-testing the timing behavior is so easy.\r\n\r\n## Testing\r\n\r\nYou can run the tests using the offical [Unity Testing Tools](https://www.assetstore.unity3d.com/#/content/13802). Just install the Unity package and use the [Unit Test Runner](http://www.tallior.com/introduction-to-unity-test-tools/).\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}